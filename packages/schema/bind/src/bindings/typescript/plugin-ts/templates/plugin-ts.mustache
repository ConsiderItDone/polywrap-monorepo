import { 
  Plugin, 
  PluginFactory, 
  PluginPackageManifest, 
  PluginModules, 
  PluginModule, 
  InvokableModules 
} from "@web3api/core-js";
{{#modules}}
{{#env}}
import { loadEnv as load{{#toClassName}}{{name}}{{/toClassName}}Env, {{#toClassName}}{{name}}{{/toClassName}}Env } from "../{{modulePath}}";
{{/env}}
import { {{#toClassName}}{{name}}{{/toClassName}}, {{#toClassName}}{{name}}{{/toClassName}}Configs } from "../{{modulePath}}";
{{/modules}}
import { manifest } from "./manifest";

export interface {{#toClassName}}{{projectName}}{{/toClassName}}PluginConfigs {
{{#modules}}
  {{name}}: {{#toClassName}}{{name}}{{/toClassName}}Configs;
{{/modules}}
}

class {{#toClassName}}{{projectName}}{{/toClassName}}Plugin extends Plugin {
  constructor(private _configs: {{#toClassName}}{{projectName}}{{/toClassName}}PluginConfigs) {
    super();
  }

  public static manifest(): PluginPackageManifest {
    return manifest;
  }

  public getModules(): PluginModules {
    return {
      {{#modules}}
      {{name}}: new {{#toClassName}}{{name}}{{/toClassName}}(this._configs.{{name}}),
      {{/modules}}
    };
  }

  public loadModuleEnv(module: InvokableModules, env: unknown ): void {
    switch(module) {
      {{#modules}}
      {{#env}}
      case "{{name}}":
        return load{{#toClassName}}{{name}}{{/toClassName}}Env(env as {{#toClassName}}{{name}}{{/toClassName}}Env);
      {{/env}}
      {{/modules}}
      default:
        throw new Error(`Unknown module: ${module}`);
    }
  }
}

export const {{#toFuncName}}{{projectName}}{{/toFuncName}}Plugin: PluginFactory<
  {{#toClassName}}{{projectName}}{{/toClassName}}PluginConfigs
> = (
  opts: {{#toClassName}}{{projectName}}{{/toClassName}}PluginConfigs
) => {
  return {
    factory: () => new {{className}}Plugin(opts),
    manifest: manifest,
  };
};
export const plugin = {{#toFuncName}}{{projectName}}{{/toFuncName}}Plugin;
