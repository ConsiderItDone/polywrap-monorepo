import { SchemaComposer } from "./SchemaComposer";
import { Project } from "./Project";
import { step, withSpinner } from "./helpers";
import { getIntl } from "./internationalization";

import { OutputDirectory, writeDirectory } from "@web3api/schema-bind";
import { parseSchema } from "@web3api/schema-parse";
import path from "path";
import fs, { readFileSync } from "fs";
import * as gluegun from "gluegun";
import { Ora } from "ora";
import Mustache from "mustache";
import { defineMessages } from "@formatjs/intl";

export interface CodeGeneratorConfig {
  outputDir: string;
  generationFile: string;
  project: Project;
  schemaComposer: SchemaComposer;
}

export class CodeGenerator {
  private _schema: string | undefined = "";

  constructor(private _config: CodeGeneratorConfig) {}

  public async generate(): Promise<boolean> {
    try {
      // Compile the API
      await this._generateCode();

      return true;
    } catch (e) {
      gluegun.print.error(e);
      return false;
    }
  }

  private async _generateCode() {
    const { schemaComposer, project } = this._config;

    const run = async (spinner?: Ora) => {
      // Make sure that the output dir exists, if not create a new one
      if (!fs.existsSync(this._config.outputDir)) {
        fs.mkdirSync(this._config.outputDir);
      }

      // Get the fully composed schema
      const composed = await schemaComposer.getComposedSchemas();
      const typeInfo = parseSchema(composed.combined || "");
      this._schema = composed.combined;

      // Check the generation file if it has the proper run() method
      // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports, @typescript-eslint/naming-convention
      const generator = await require(this._config.generationFile);
      if (!generator) {
        const wrongGenFileMessage = getIntl().formatMessage({
          id: "lib_codeGenerator_wrongGenFile",
          defaultMessage: "The generation file provided is wrong.",
          description: "the file is undefined or null",
        });
        throw Error(wrongGenFileMessage);
      }

      const { run } = generator;
      if (!run) {
        const noRunMessage = getIntl().formatMessage({
          id: "lib_codeGenerator_noRunMethod",
          defaultMessage:
            "The generation file provided doesn't have the 'run' method.",
          description: "file is missing necessary method",
        });
        throw Error(noRunMessage);
      }

      const output: OutputDirectory = {
        entries: [],
      };

      await run(output, {
        typeInfo,
        generate: (templatePath: string, config: unknown) =>
          this._generateTemplate(templatePath, config, spinner),
      });

      writeDirectory(this._config.outputDir, output, (templatePath: string) =>
        this._generateTemplate(templatePath, typeInfo, spinner)
      );
    };

    if (project.quiet) {
      await run();
    } else {
      const intl = getIntl();
      const messages = defineMessages({
        text: {
          id: "lib_codeGenerator_genCodeText",
          defaultMessage: "Generate types",
          description: "",
        },
        error: {
          id: "lib_codeGenerator_genCodeError",
          defaultMessage: "Failed to generate types",
          description: "",
        },
        warning: {
          id: "lib_codeGenerator_genCodeWarning",
          defaultMessage: "Warnings while generating types",
          description: "",
        },
      });
      await withSpinner(
        intl.formatMessage(messages.text),
        intl.formatMessage(messages.error),
        intl.formatMessage(messages.warning),
        async (spinner) => {
          return run(spinner);
        }
      );
    }
  }

  private _generateTemplate(
    templatePath: string,
    config: unknown,
    spinner?: Ora
  ): string {
    const { project } = this._config;
    const intl = getIntl();

    if (!project.quiet && spinner) {
      const stepMessage = intl.formatMessage(
        {
          id: "lib_codeGenerator_genTemplateStep",
          defaultMessage: "Generating types from {path}",
          description: "",
        },
        { path: `${templatePath}` }
      );
      step(spinner, stepMessage);
    }

    templatePath = path.join(
      path.dirname(this._config.generationFile),
      templatePath
    );

    const template = readFileSync(templatePath);
    const types =
      typeof config === "object" && config !== null ? config : { config };
    let content = Mustache.render(template.toString(), {
      ...types,
      schema: this._schema,
    });

    const noModifyMessage = intl.formatMessage({
      id: "lib_codeGenerator_templateNoModify",
      defaultMessage: "NOTE: This is generated by 'w3 codegen', DO NOT MODIFY",
      description: "",
    });

    content = `// ${noModifyMessage}

${content}
`;

    return content;
  }
}
